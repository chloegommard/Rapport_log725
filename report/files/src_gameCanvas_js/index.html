<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>Plato - src\gameCanvas.js</title>

    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="description" content="" />
    <meta name="author" content="" />

    <!--[if lt IE 9]>
      <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <link href="../../assets/css/vendor/morris.css" rel="stylesheet" />
    <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" />
    <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" />
    <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" />
    <link href="../../assets/css/plato.css" rel="stylesheet" />
    <link href="../../assets/css/plato-file.css" rel="stylesheet" />
  </head>

  <body>
    <div class="navbar navbar-fixed-top">
      <div class="container">
        <a class="navbar-brand" href="http://github.com/es-analysis/plato"
          >Plato on Github</a
        >
        <ul class="nav navbar-nav">
          <li>
            <a href="../../index.html">Report Home</a>
          </li>
        </ul>
      </div>
    </div>

    <div class="jumbotron">
      <div class="container">
        <h1>src\gameCanvas.js</h1>
      </div>
    </div>

    <div class="container aggregate-stats">
      <div class="row">
        <div class="col-md-6">
          <h2 class="header">
            Maintainability
            <a
              href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"
              ><i
                class="icon icon-info-sign"
                rel="popover"
                data-placement="top"
                data-trigger="hover"
                data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability."
                data-original-title="Maintainability Index"
                data-container="body"
              ></i
            ></a>
          </h2>
          <p class="stat">57.34</p>
        </div>
        <div class="col-md-6">
          <h2 class="header">
            Lines of code
            <i
              class="icon icon-info-sign"
              rel="popover"
              data-placement="top"
              data-trigger="hover"
              data-content="Source Lines of Code / Logical Lines of Code"
              data-original-title="SLOC/LSLOC"
              data-container="body"
            ></i>
          </h2>
          <p class="stat">658</p>
        </div>
      </div>
      <div class="row historical">
        <div class="col-md-6">
          <p id="chart_historical_maint" class="chart"></p>
        </div>
        <div class="col-md-6">
          <p id="chart_historical_sloc" class="chart"></p>
        </div>
      </div>
      <div class="row">
        <div class="col-md-6">
          <h2 class="header">
            Difficulty
            <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"
              ><i
                class="icon icon-info-sign"
                rel="popover"
                data-placement="top"
                data-trigger="hover"
                data-content="The difficulty measure is related to the difficulty of the program to write or understand."
                data-original-title="Difficulty"
                data-container="body"
              ></i
            ></a>
          </h2>
          <p class="stat">149.63</p>
        </div>
        <div class="col-md-6">
          <h2 class="header">
            Estimated Errors
            <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"
              ><i
                class="icon icon-info-sign"
                rel="popover"
                data-placement="top"
                data-trigger="hover"
                data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation."
                data-original-title="Delivered Bugs"
                data-container="body"
              ></i
            ></a>
          </h2>
          <p class="stat">8.18</p>
        </div>
      </div>
    </div>

    <div class="container charts">
      <div class="row">
        <h2 class="header">Function weight</h2>
      </div>
      <div class="row">
        <div class="col-md-6">
          <h3 class="chart-header">
            By Complexity
            <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"
              ><i
                class="icon icon-info-sign"
                rel="popover"
                data-placement="top"
                data-trigger="hover"
                data-content="This metric counts the number of distinct paths through a block of code. Lower values are better."
                data-original-title="Cyclomatic Complexity"
                data-container="body"
              ></i
            ></a>
          </h3>
          <div id="fn-by-complexity" class="stat"></div>
        </div>
        <div class="col-md-6">
          <h3 class="chart-header">
            By SLOC
            <i
              class="icon icon-info-sign"
              rel="popover"
              data-placement="top"
              data-trigger="hover"
              data-content="Source Lines of Code / Logical Lines of Code"
              data-original-title="SLOC/LSLOC"
              data-container="body"
            ></i>
          </h3>
          <div id="fn-by-sloc" class="stat"></div>
        </div>
      </div>
    </div>

    <div class="container">
      <div class="row">
        <textarea id="file-source" class="col-md-12">
/* micropolisJS. Adapted by Graeme McCutcheon from Micropolis.
 *
 * This code is released under the GNU GPL v3, with some additional terms.
 * Please see the files LICENSE and COPYING for details. Alternatively,
 * consult http://micropolisjs.graememcc.co.uk/LICENSE and
 * http://micropolisjs.graememcc.co.uk/COPYING
 *
 */

import { AnimationManager } from &#039;./animationManager&#039;;
import { GameMap } from &#039;./gameMap&#039;;
import { MiscUtils } from &#039;./miscUtils&#039;;
import { MouseBox } from &#039;./mouseBox&#039;;
import { Position } from &#039;./position&#039;;
import { TileSet } from &#039;./tileSet&#039;;
import { TILE_INVALID } from &quot;./tileValues&quot;;

function GameCanvas(id, parentNode) {
  if (!(this instanceof GameCanvas))
    return new GameCanvas(id, parentNode, width, height);

  if (arguments.length &lt; 1)
    throw new Error(&#039;Attempt to construct a GameCanvas with no parameters&#039;);

  // Argument shuffling
  if (parentNode === undefined) {
    // No ID supplied
    parentNode = id;
    id = GameCanvas.DEFAULT_ID;
  }

  if (typeof(parentNode) === &#039;string&#039;) {
    var orig = parentNode;
    parentNode = $(MiscUtils.normaliseDOMid(parentNode));
    parentNode = parentNode.length === 0 ? null : parentNode[0];
    if (parentNode === null)
      throw new Error(&#039;Node &#039; + orig + &#039; not found&#039;);
  }

  this._canvas = document.createElement(&#039;canvas&#039;);
  this._canvas.id = id;

  // The canvas is assumed to fill its container on-screen
  var rect = parentNode.getBoundingClientRect();
  this._canvas.width = rect.width;
  this._canvas.height = rect.height;
  this._canvas.style.margin = &#039;0&#039;;
  this._canvas.style.padding = &#039;0&#039;;

  this._pendingTileSet = null;

  // Remove any existing element with the same id
  var current = document.getElementById(id);
  if (current !== null) {
    if  (current.parentNode === parentNode)
      parentNode.replaceChild(this._canvas, current);
    else
      throw new Error(&#039;ID &#039; + id + &#039; already exists in document!&#039;);
  } else
    parentNode.appendChild(this._canvas);

  this.ready = false;
}


GameCanvas.prototype.init = function(map, tileSet, spriteSheet, animationManager) {
  animationManager = animationManager || new AnimationManager(map);

  if (arguments.length &lt; 3)
    throw new Error(&#039;GameCanvas constructor called with too few arguments &#039; + [].toString.apply(arguments));

  if (!tileSet.isValid)
    throw new Error(&#039;TileSet not ready!&#039;);

  this._spriteSheet = spriteSheet;
  this._tileSet = tileSet;
  var w = this._tileSet.tileWidth;
  this._map = map;
  this.animationManager = new AnimationManager(map);

  if (this._canvas.width &lt; w || this._canvas.height &lt; w)
    throw new Error(&#039;Canvas too small!&#039;);

  // Whether to allow off-map scrolling
  this._allowScrolling = true;

  // An array indexed by tile offset containing the tileValue last painted there
  this._lastPaintedTiles = null;
  this._currentPaintedTiles = []; // for future use

  // Last time we painted, the canvas was this many tiles wide and tall
  this._lastPaintedWidth = -1;
  this._lastPaintedHeight = -1;

  // Last time we painted, the canvas was this wide and tall in pixels (determines whether we
  // can safely call putImageData)
  this._lastCanvasWidth = -1;
  this._lastCanvasHeight = -1;

  // After painting tiles, we store the image data here before painting sprites and mousebox
  this._lastCanvasData = null;

  this._calculateDimensions();

  // Have the dimensions changed since the last paint?
  this._pendingDimensionChange = false;
  var onResize = function(e) {
    this._pendingDimensionChange = true;
  }.bind(this);

  // Recompute canvas dimensions on resize
  window.addEventListener(&#039;resize&#039;, onResize, false);

  // Order is important here. ready must be set before the call to centreOn below
  this.ready = true;
  this.centreOn(Math.floor(this._map.width / 2), Math.floor(this._map.height / 2));

  this.paint(null, null);
};


GameCanvas.prototype._calculateDimensions = function(force) {
  force = force || false;

  // The canvas is assumed to fill its container on-screen
  var canvasWidth = this.canvasWidth = this._canvas.parentNode.clientWidth;
  var canvasHeight = this.canvasHeight = this._canvas.parentNode.clientHeight;

  if (canvasHeight === this._lastCanvasHeight &amp;&amp; canvasWidth === this._lastCanvasWidth &amp;&amp; !force)
    return;

  this._canvas.width = canvasWidth;
  this._canvas.height = canvasHeight;

  var w = this._tileSet.tileWidth;

  // How many tiles fit?
  this._wholeTilesInViewX = Math.floor(canvasWidth / w);
  this._wholeTilesInViewY = Math.floor(canvasHeight / w);
  this._totalTilesInViewX = Math.ceil(canvasWidth / w);
  this._totalTilesInViewY = Math.ceil(canvasHeight / w);

  if (this._allowScrolling) {
    // The min/max properties denote how far we will let the canvas&#039; origin move: the map
    // should be visible in at least half the canvas
    this.minX = 0 - Math.ceil(Math.floor(canvasWidth/w) / 2);
    this.maxX = (this._map.width - 1) - Math.ceil(Math.floor(canvasWidth/w) / 2);
    this.minY = 0 - Math.ceil(Math.floor(canvasHeight/w) / 2);
    this.maxY = (this._map.height - 1) - Math.ceil(Math.floor(canvasHeight/w) / 2);
    this._totalTilesInViewY = Math.ceil(canvasHeight / w);
  } else {
    this.minX = 0;
    this.minY = 0;
    this.maxX = this._map.width - this._totalTilesInViewX;
    this.maxY = this._map.height - this._totalTilesInViewY;
  }

  this._pendingDimensionChange = true;
};


// NOTE: Canvas must be visible when this is called
GameCanvas.prototype.disallowOffMap = function() {
  this._allowScrolling = false;
  this._lastPaintedTiles = null;
  this._calculateDimensions(true);
};


GameCanvas.prototype.moveNorth = function() {
  if (!this.ready)
    throw new Error(&#039;Not ready!&#039;);

  if (this._originY &gt; this.minY)
    this._originY--;
};


GameCanvas.prototype.moveEast = function() {
  if (!this.ready)
    throw new Error(&#039;Not ready!&#039;);

  if (this._originX &lt; this.maxX)
    this._originX++;
};


GameCanvas.prototype.moveSouth = function() {
  if (!this.ready)
    throw new Error(&#039;Not ready!&#039;);

  if (this._originY &lt; this.maxY)
    this._originY++;
};


GameCanvas.prototype.moveWest = function() {
  if (!this.ready)
    throw new Error(&#039;Not ready!&#039;);

  if (this._originX &gt; this.minX)
    this._originX--;
};


GameCanvas.prototype.moveTo = function(x, y) {
  if (arguments.length &lt; 1)
    throw new Error(&#039;GameCanvas moveTo called with no arguments&#039;);

  if (!this.ready)
    throw new Error(&#039;Not ready!&#039;);

  if (x &lt; this.minX || x &gt; this.maxX ||
      y &lt; this.minY || y &gt; this.maxY)
    throw new Error(&#039;Coordinates out of bounds&#039;);

  this._originX = x;
  this._originY = y;
};


GameCanvas.prototype.centreOn = function(x, y) {
  if (arguments.length &lt; 1)
    throw new Error(&#039;GameCanvas centreOn called with no arguments&#039;);

  if (!this.ready)
    throw new Error(&#039;Not ready!&#039;);

  if (y === undefined) {
    y = x.y;
    x = x.x;
  }

  // XXX Need to fix so that centres on best point if bounds fall outside
  // XXX min/max
  var originX = Math.floor(x) - Math.ceil(this._wholeTilesInViewX / 2);
  var originY = Math.floor(y) - Math.ceil(this._wholeTilesInViewY / 2);

  if (originX &gt; this.maxX)
    originX = this.maxX;
  if (originX &lt; this.minX)
    originX = this.minX;
  if (originY &gt; this.maxY)
    originY = this.maxY;
  if (originY &lt; this.minY)
    originY = this.minY;

  this._originX = originX;
  this._originY = originY;
};


GameCanvas.prototype.getTileOrigin = function() {
  var e = new Error(&#039;Not ready!&#039;);

  if (!this.ready)
    throw e;

  return {x: this._originX, y: this._originY};
};


GameCanvas.prototype.getMaxTile = function() {
  var e = new Error(&#039;Not ready!&#039;);

  if (!this.ready)
    throw e;

  return {x: this._originX + this._totalTilesInViewX - 1, y: this._originY + this._totalTilesInViewY - 1};
};


GameCanvas.prototype.canvasCoordinateToTileOffset = function(x, y) {
  if (arguments.length &lt; 2)
    throw new Error(&#039;GameCanvas canvasCoordinateToTileOffset called with too few arguments &#039; + [].toString.apply(arguments));

  if (!this.ready)
    throw new Error(&#039;Not ready!&#039;);

  return {x: Math.floor(x / this._tileSet.tileWidth),
          y: Math.floor(y / this._tileSet.tileWidth)};
};


GameCanvas.prototype.canvasCoordinateToTileCoordinate = function(x, y) {
  if (arguments.length &lt; 2)
    throw new Error(&#039;GameCanvas canvasCoordinateToTileCoordinate called with too few arguments &#039; + [].toString.apply(arguments));

  if (!this.ready)
    throw new Error(&#039;Not ready!&#039;);

  if (x &gt;= this.canvasWidth || y &gt;= this.canvasHeight)
    return null;

  return {x: this._originX + Math.floor(x/this._tileSet.tileWidth),
          y: this._originY + Math.floor(y/this._tileSet.tileWidth)};
};


GameCanvas.prototype.canvasCoordinateToPosition = function(x, y) {
  if (arguments.length &lt; 2)
    throw new Error(&#039;GameCanvas canvasCoordinateToPosition called with too few arguments &#039; + [].toString.apply(arguments));

  if (!this.ready)
    throw new Error(&#039;Not ready!&#039;);

  if (x &gt;= this.canvasWidth || y &gt;= this.canvasHeight)
    return null;

  x = this._originX + Math.floor(x / this._tileSet.tileWidth);
  y = this._originY + Math.floor(y / this._tileSet.tileWidth);


  if (x &lt; 0 || x &gt;= this._map.width || y &lt; 0 || y &gt;= this._map.height)
    return null;

  return new Position(x, y);
};



GameCanvas.prototype.positionToCanvasCoordinate = function(p) {
  if (arguments.length &lt; 1)
    throw new Error(&#039;GameCanvas positionToCanvasCoordinate called with too few arguments &#039; + [].toString.apply(arguments));

  return this.tileToCanvasCoordinate(p);
};



GameCanvas.prototype.tileToCanvasCoordinate = function(x, y) {
  if (arguments.length &lt; 1)
    throw new Error(&#039;GameCanvas tileToCanvasCoordinate  called with too few arguments &#039; + [].toString.apply(arguments));

  if (!this.ready)
    throw new Error(&#039;Not ready!&#039;);

  if (y === undefined) {
    y = x.y;
    x = x.x;
  }

  if (x === undefined || y === undefined || x &lt; this.minX || y &lt; this.minY ||
      x &gt; (this.maxX + this._totalTilesInViewX - 1) ||
      y &gt; (this.maxY + this._totalTilesInViewY - 1))
    throw e;

  if (x &lt; this._originX || x &gt;= this._originX + this._totalTilesInViewX ||
      y &lt; this._originY || y &gt;= this._originY + this._totalTilesInViewY)
    return null;

  return {x: (x - this._originX) * this._tileSet.tileWidth,
          y: (y - this._originY) * this._tileSet.tileWidth};
};



GameCanvas.prototype.changeTileSet = function(tileSet) {
  if (!this.ready)
    throw new Error(&#039;Not ready!&#039;);

  if (!tileSet.isValid)
    throw new Error(&#039;new tileset not loaded&#039;);

  this._pendingTileSet = tileSet;
};



GameCanvas.prototype._screenshot = function(onlyVisible) {
  if (onlyVisible)
    return this._canvas.toDataURL();

  var tempCanvas = document.createElement(&#039;canvas&#039;);
  tempCanvas.width = this._map.width * this._tileSet.tileWidth;
  tempCanvas.height = this._map.height * this._tileSet.tileWidth;
  var ctx = tempCanvas.getContext(&#039;2d&#039;);

  for (var x = 0; x &lt; this._map.width; x++) {
    for (var y = 0; y &lt; this._map.height; y++) {
      this._paintOne(ctx, this._map.getTileValue(x, y), x, y);
    }
  }
  return tempCanvas.toDataURL();
};


GameCanvas.prototype.screenshotMap = function() {
  return this._screenshot(false);
};


GameCanvas.prototype.screenshotVisible = function() {
  return this._screenshot(true);
};


GameCanvas.prototype.shoogle = function() {
  // TODO Earthquakes
};


GameCanvas.prototype._processSprites = function(ctx, spriteList) {
  var spriteDamage = [];
  var tileWidth = this._tileSet.tileWidth;

  for (var i = 0, l = spriteList.length; i &lt; l; i++) {
    var sprite = spriteList[i];
    try {
      ctx.drawImage(this._spriteSheet,
                    (sprite.frame - 1) * 48,
                    (sprite.type - 1) * 48,
                    sprite.width,
                    sprite.width,
                    sprite.x + sprite.xOffset - this._originX * 16,
                    sprite.y + sprite.yOffset - this._originY * 16,
                    sprite.width,
                    sprite.width);
    } catch (e) {
      throw new Error(&#039;Failed to draw sprite &#039; + sprite.type + &#039; frame &#039; + sprite.frame + &#039; at &#039; + sprite.x +  &#039;, &#039; + sprite.y);
    }

    // sprite values are in pixels
    spriteDamage.push({x: Math.floor((sprite.x + sprite.xOffset - this._originX * 16) / tileWidth),
                       xBound: Math.ceil((sprite.x + sprite.xOffset + sprite.width - this._originX * 16) / tileWidth),
                       y: Math.floor((sprite.y + sprite.yOffset - this._originY * 16) / tileWidth),
                       yBound: Math.ceil((sprite.y + sprite.yOffset + sprite.height - this._originY * 16) / tileWidth)});
  }

  return spriteDamage;
};


// Draws a mouse outline around the selected tiles. The mouse object is assumed to contain x and y properties which
// express the coordinate of the top-left of the box in terms of the number of tiles from the top left. It should
// also contain a width and height that are again expressed in terms of the number of tiles. The colour property
// naturally defines the colour of the painted box.
GameCanvas.prototype._processMouse = (function() {
  var damage = {x: 0, xBound: 0, y: 0, yBound: 0};

  return function(mouse) {
    if (mouse.width === 0 || mouse.height === 0)
      return;

    // For outlines bigger than 2x2 (in either dimension) assume the mouse is offset by
    // one tile
    var mouseX = mouse.x;
    var mouseY = mouse.y;
    var mouseWidth = mouse.width;
    var mouseHeight = mouse.height;
    var options = {colour: mouse.colour, outline: true};

    if (mouseWidth &gt; 2)
      mouseX -= 1;
    if (mouseHeight &gt; 2)
      mouseY -= 1;

    var offMap = (this._originX + mouseX &lt; 0 &amp;&amp; this._originX + mouseX + mouseWidth &lt;= 0) ||
                 (this._originY + mouseY &lt; 0 &amp;&amp; this._originY + mouseY + mouseHeight &lt;= 0) ||
                 this._originX + mouseX &gt;= this._map.width || this._originY + mouseY &gt;= this._map.height;

    if (offMap) {
      damage.x = damage.xBound = mouseX;
      damage.y = damage.yBound = mouseY;
      return damage;
    }

    var pos = {x: mouseX * this._tileSet.tileWidth, y: mouseY * this._tileSet.tileWidth};
    var width = mouseWidth * this._tileSet.tileWidth;
    var height = mouseHeight * this._tileSet.tileWidth;
    MouseBox.draw(this._canvas, pos, width, height, options);

    // Return an object representing tiles that were damaged that will need redrawn
    // Note that we must take an extra tile either side to account for the outline
    damage.x = mouseX - 1;
    damage.xBound = mouseX + mouseWidth + 2;
    damage.y = mouseY - 1;
    damage.yBound = mouseY + mouseWidth + 2;
    return damage;
  };
})();


GameCanvas.prototype._paintVoid = function(ctx, x, y) {
  var w = this._tileSet.tileWidth;
  ctx.fillStyle = &#039;black&#039;;
  ctx.fillRect(x * w, y * w, w, w);
};


GameCanvas.prototype._paintOne = function(ctx, tileVal, x, y) {
  if (tileVal === TILE_INVALID) {
    this._paintVoid(ctx, x, y);
    return;
  }

  var src = this._tileSet[tileVal];
  try {
    ctx.drawImage(src, x * this._tileSet.tileWidth, y * this._tileSet.tileWidth);
  } catch (e) {
    var mapX = this._originX + x;
    var mapY = this._originY + y;
    throw new Error(&#039;Failed to draw tile &#039; + tileVal + &#039; at &#039; + x + &#039;, &#039; + y + &#039; (map &#039; + mapX + &#039;, &#039; + mapY + &#039; tile &#039; + (this._map.testBounds(mapX, mapY) ? this._map.getTileValue(mapX, mapY) : &#039;?? (Out of bounds)&#039;) + &#039;)&#039;);
  }
};


GameCanvas.prototype._paintTiles = function(ctx, paintData) {
  var x, y, row, index;
  var lastPaintedTiles = this._lastPaintedTiles;

  var width = this._totalTilesInViewX;
  var height = this._totalTilesInViewY;

  if (lastPaintedTiles !== null) {
    // We have painted the canvas before. There are 3 possibilities:
    //  - The canvas is exactly the same size as last time we painted
    //  - The canvas has grown
    //  - The canvas has shrunk
    //
    // In any case, we want to find the minimal area that was onscreen last paint
    // and this paint, and iterate over those tiles, repainting where necessary
    var xBound = Math.min(this._lastPaintedWidth, width);
    var yBound = Math.min(this._lastPaintedHeight, height);

    // Loop over the common area that we painted last time. Compare the current value against what was there last time
    for (y = 0; y &lt; yBound; y++) {
      for (x = 0; x &lt; xBound; x++) {
        index  = y * xBound + x;
        if (lastPaintedTiles[index] === paintData[index])
          continue;

        // Tile is different: repaint
        this._paintOne(ctx, paintData[index], x, y);
      }
    }

    // Do we have more tiles than before? Paint the extra width and/or the extra height
    if (width &gt; this._lastPaintedWidth) {
      for (y = 0; y &lt; height; y++) {
        for (x = this._lastPaintedWidth; x &lt; width; x++) {
          index  = y * width + x;
          this._paintOne(ctx, paintData[index], x, y);
        }
      }
    }

    if (height &gt; this._lastPaintedHeight) {
      for (y = this._lastPaintedHeight; y &lt; height; y++) {
        for (x = 0; x &lt; width; x++) {
          index  = y * width + x;
          this._paintOne(ctx, paintData[index], x, y);
        }
      }
    }
  } else {
    // Full paint
    for (y = 0; y &lt; height; y++) {
      for (x = 0; x &lt; width; x++) {
        index = y * width + x;
        this._paintOne(ctx, paintData[index], x, y);
      }
    }
  }

  // Stash data
  this._lastPaintedWidth = width;
  this._lastPaintedHeight = height;

  // Rotate tile data
  var temp = this._lastPaintedTiles;
  this._lastPaintedTiles = paintData;
  this._currentPaintedTiles = temp;
};


GameCanvas.prototype.paint = function(mouse, sprites, isPaused) {
  var i, l, x, y, row, damaged, xBound, yBound, index;

  if (!this.ready)
    throw new Error(&#039;Not ready!&#039;);

  var ctx = this._canvas.getContext(&#039;2d&#039;);
  var lastPaintedTiles = this._lastPaintedTiles;

  // Recompute our dimensions if there has been a resize since last paint
  if (this._pendingDimensionChange || this._pendingTileSet) {
    this._calculateDimensions();
    this._pendingDimensionChange = false;

    // Change tileSet if necessary
    if (this._pendingTileSet !== null)
      this._tileSet = this._pendingTileSet;

    // If the dimensions or tileset has changed, set each entry in lastPaintedTiles to a bogus value to force a
    // repaint. Note: we use -2 as our bogus value; -1 would paint the black void
    if (this._pendingTileSet || this.canvasWidth !== this._lastCanvasWidth || this.canvasHeight !== this._lastCanvasHeight) {
      ctx.clearRect(0, 0, this.canvasWidth, this.canvasHeight);

      for (y = 0, l = (lastPaintedTiles !== null ? lastPaintedTiles.length : 0); y &lt; l; y++)
        lastPaintedTiles[y] = -2;
    }

    this._pendingTileSet = null;
  }

  var paintWidth = this._totalTilesInViewX;
  var paintHeight = this._totalTilesInViewY;

  // Fill an array with the values we need to paint
  var tileValues = this._map.getTileValuesForPainting(this._originX, this._originY, paintWidth, paintHeight, this._currentPaintedTiles);

  // Adjust for animations
  this.animationManager.getTiles(tileValues, this._originX, this._originY, paintWidth, paintHeight, isPaused);

  this._paintTiles(ctx, tileValues);
  // The _paintTiles call updates this._lastPaintedTiles. Update our cached copy
  lastPaintedTiles = this._lastPaintedTiles;

  // Stash various values for next paint
  this._lastCanvasWidth = this.canvasWidth;
  this._lastCanvasHeight = this.canvasHeight;

  if (!mouse &amp;&amp; !sprites) {
    return;
  }

  if (mouse) {
    damaged = this._processMouse(mouse);

    for (y = Math.max(0, damaged.y), yBound = Math.min(paintHeight, damaged.yBound); y &lt; yBound; y++) {
      for (x = Math.max(0, damaged.x), xBound = Math.min(paintWidth, damaged.xBound); x &lt; xBound; x++) {
        index = [y * paintWidth + x];
        // Note: we can&#039;t use TILE_INVALID (-1) as that in some sense is a valid tile for the void!
        lastPaintedTiles[index] = -2;
      }
    }
  }

  if (sprites) {
    damaged = this._processSprites(ctx, sprites);
    for (i = 0, l = damaged.length; i &lt; l; i++) {
      var damagedArea = damaged[i];
      for (y = Math.max(0, damagedArea.y), yBound = Math.min(damagedArea.yBound, paintHeight); y &lt; yBound; y++) {
        for (x = Math.max(0, damagedArea.x), xBound = Math.min(damagedArea.xBound, paintWidth); x &lt; xBound; x++) {
          index = [y * paintWidth + x];
          this._lastPaintedTiles[index] = -2;
        }
      }
    }
  }
};


GameCanvas.DEFAULT_ID = &#039;MicropolisCanvas&#039;;


export { GameCanvas };</textarea
        >
      </div>
    </div>

    <footer class="footer">
      <div class="container">
        <p>.</p>
      </div>
    </footer>

    <script type="text/html" id="complexity-popover-template">
      <div class="complexity-notice">
        Complexity : {{ cyclomatic }} <br />
        Length : {{ halstead.length }} <br />
        Difficulty : {{ halstead.difficulty.toFixed(2) }} <br />
        Est # bugs : {{ halstead.bugs.toFixed(2) }}<br />
      </div>
    </script>

    <script
      type="text/javascript"
      src="../../assets/scripts/bundles/core-bundle.js"
    ></script>
    <script
      type="text/javascript"
      src="../../assets/scripts/bundles/codemirror.js"
    ></script>
    <script
      type="text/javascript"
      src="../../assets/scripts/codemirror.markpopovertext.js"
    ></script>
    <script type="text/javascript" src="report.js"></script>
    <script type="text/javascript" src="report.history.js"></script>
    <script
      type="text/javascript"
      src="../../assets/scripts/plato-file.js"
    ></script>
  </body>
</html>
