<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>Plato - src\residential.js</title>

    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="description" content="" />
    <meta name="author" content="" />

    <!--[if lt IE 9]>
      <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <link href="../../assets/css/vendor/morris.css" rel="stylesheet" />
    <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" />
    <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" />
    <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" />
    <link href="../../assets/css/plato.css" rel="stylesheet" />
    <link href="../../assets/css/plato-file.css" rel="stylesheet" />
  </head>

  <body>
    <div class="navbar navbar-fixed-top">
      <div class="container">
        <a class="navbar-brand" href="http://github.com/es-analysis/plato"
          >Plato on Github</a
        >
        <ul class="nav navbar-nav">
          <li>
            <a href="../../index.html">Report Home</a>
          </li>
        </ul>
      </div>
    </div>

    <div class="jumbotron">
      <div class="container">
        <h1>src\residential.js</h1>
      </div>
    </div>

    <div class="container aggregate-stats">
      <div class="row">
        <div class="col-md-6">
          <h2 class="header">
            Maintainability
            <a
              href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"
              ><i
                class="icon icon-info-sign"
                rel="popover"
                data-placement="top"
                data-trigger="hover"
                data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability."
                data-original-title="Maintainability Index"
                data-container="body"
              ></i
            ></a>
          </h2>
          <p class="stat">57.52</p>
        </div>
        <div class="col-md-6">
          <h2 class="header">
            Lines of code
            <i
              class="icon icon-info-sign"
              rel="popover"
              data-placement="top"
              data-trigger="hover"
              data-content="Source Lines of Code / Logical Lines of Code"
              data-original-title="SLOC/LSLOC"
              data-container="body"
            ></i>
          </h2>
          <p class="stat">319</p>
        </div>
      </div>
      <div class="row historical">
        <div class="col-md-6">
          <p id="chart_historical_maint" class="chart"></p>
        </div>
        <div class="col-md-6">
          <p id="chart_historical_sloc" class="chart"></p>
        </div>
      </div>
      <div class="row">
        <div class="col-md-6">
          <h2 class="header">
            Difficulty
            <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"
              ><i
                class="icon icon-info-sign"
                rel="popover"
                data-placement="top"
                data-trigger="hover"
                data-content="The difficulty measure is related to the difficulty of the program to write or understand."
                data-original-title="Difficulty"
                data-container="body"
              ></i
            ></a>
          </h2>
          <p class="stat">103.57</p>
        </div>
        <div class="col-md-6">
          <h2 class="header">
            Estimated Errors
            <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"
              ><i
                class="icon icon-info-sign"
                rel="popover"
                data-placement="top"
                data-trigger="hover"
                data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation."
                data-original-title="Delivered Bugs"
                data-container="body"
              ></i
            ></a>
          </h2>
          <p class="stat">3.17</p>
        </div>
      </div>
    </div>

    <div class="container charts">
      <div class="row">
        <h2 class="header">Function weight</h2>
      </div>
      <div class="row">
        <div class="col-md-6">
          <h3 class="chart-header">
            By Complexity
            <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"
              ><i
                class="icon icon-info-sign"
                rel="popover"
                data-placement="top"
                data-trigger="hover"
                data-content="This metric counts the number of distinct paths through a block of code. Lower values are better."
                data-original-title="Cyclomatic Complexity"
                data-container="body"
              ></i
            ></a>
          </h3>
          <div id="fn-by-complexity" class="stat"></div>
        </div>
        <div class="col-md-6">
          <h3 class="chart-header">
            By SLOC
            <i
              class="icon icon-info-sign"
              rel="popover"
              data-placement="top"
              data-trigger="hover"
              data-content="Source Lines of Code / Logical Lines of Code"
              data-original-title="SLOC/LSLOC"
              data-container="body"
            ></i>
          </h3>
          <div id="fn-by-sloc" class="stat"></div>
        </div>
      </div>
    </div>

    <div class="container">
      <div class="row">
        <textarea id="file-source" class="col-md-12">
/* micropolisJS. Adapted by Graeme McCutcheon from Micropolis.
 *
 * This code is released under the GNU GPL v3, with some additional terms.
 * Please see the files LICENSE and COPYING for details. Alternatively,
 * consult http://micropolisjs.graememcc.co.uk/LICENSE and
 * http://micropolisjs.graememcc.co.uk/COPYING
 *
 */

import { Config } from &#039;./config&#039;;
import { Random } from &#039;./random&#039;;
import { Tile } from &#039;./tile&#039;;
import { BLBNCNBIT, ZONEBIT } from &quot;./tileFlags&quot;;
import { TileUtils } from &#039;./tileUtils&#039;;
import * as TileValues from &quot;./tileValues&quot;;
import { Traffic } from &#039;./traffic&#039;;
import { ZoneUtils } from &#039;./zoneUtils&#039;;

// Residential tiles have &#039;populations&#039; of 16, 24, 32 or 40, and value from 0 to 3. The tiles are laid out in
// increasing order of land value, cycling through each population value
var placeResidential = function(map, x, y, population, lpValue, zonePower) {
  var centreTile = ((lpValue * 4) + population) * 9 + TileValues.RZB;
  ZoneUtils.putZone(map, x, y, centreTile, zonePower);
};


// Look for housing in the adjacent 8 tiles
var getFreeZonePopulation = function(map, x, y, tileValue) {
  var count = 0;
  for (var xx = x - 1; xx &lt;= x + 1; xx++) {
    for (var yy = y - 1; yy &lt;= y + 1; yy++) {
      if (xx === x &amp;&amp; yy === y) continue;
      tileValue = map.getTileValue(xx, yy);
      if (tileValue &gt;= TileValues.LHTHR &amp;&amp; tileValue &lt;= TileValues.HHTHR)
        count += 1;
    }
  }

  return count;
};


var getZonePopulation = function(map, x, y, tileValue) {
  if (tileValue instanceof Tile)
    tileValue = tile.getValue();

  if (tileValue === TileValues.FREEZ)
    return getFreeZonePopulation(map, x, y, tileValue);

  var populationIndex = Math.floor((tileValue - TileValues.RZB) / 9) % 4 + 1;
  return populationIndex * 8 + 16;
};


// Assess a tile for suitability for a house. Prefers tiles near roads
var evalLot = function(map, x, y) {
  var xDelta = [0, 1, 0, -1];
  var yDelta = [-1, 0, 1, 0];

  if (!map.testBounds(x, y))
    return -1;

  var tileValue = map.getTileValue(x, y);
  if (tileValue &lt; TileValues.RESBASE || tileValue &gt; TileValues.RESBASE + 8)
    return -1;

  var score = 1;
  for (var i = 0; i &lt; 4; i++) {
    var edgeX = x + xDelta[i];
    var edgeY = y + yDelta[i];

    if (edgeX &lt; 0 || edgeX &gt;= map.width || edgeY &lt; 0 || edgeY &gt;= map.height)
      continue;

    tileValue = map.getTileValue(edgeX, edgeY);
    if (tileValue !== TileValues.DIRT &amp;&amp; tileValue &lt;= TileValues.LASTROAD)
      score += 1;
  }

  return score;
};


var buildHouse = function(map, x, y, lpValue) {
  var best = 0;
  var bestScore = 0;

  //  Deliberately ordered so that the centre tile is at index 0
  var xDelta = [0, -1, 0, 1, -1, 1, -1, 0, 1];
  var yDelta = [0, -1, -1, -1, 0, 0, 1, 1, 1];

  for (var i = 0; i &lt; 9; i++) {
    var xx = x + xDelta[i];
    var yy = y + yDelta[i];

    var score = evalLot(map, xx, yy);
    if (score &gt; bestScore) {
      bestScore = score;
      best = i;
    } else if (score === bestScore &amp;&amp; Random.getChance(7)) {
      // Ensures we don&#039;t always select the same position when we
      // have a choice
      best = i;
    }
  }

  if (best &gt; 0 &amp;&amp; map.testBounds(x + xDelta[best], y + yDelta[best]))
    map.setTile(x + xDelta[best], y + yDelta[best],
              TileValues.HOUSE + Random.getRandom(2) + lpValue * 3, BLBNCNBIT);
};


var growZone = function(map, x, y, blockMaps, population, lpValue, zonePower) {
  var pollution = blockMaps.pollutionDensityMap.worldGet(x, y);

  // Cough! Too polluted! No-one wants to move here!
  if (pollution &gt; 128)
    return;

  var tileValue = map.getTileValue(x, y);

  if (tileValue === TileValues.FREEZ) {
    if (population &lt; 8) {
      // Zone capacity not yet reached: build another house
      buildHouse(map, x, y, lpValue);
      ZoneUtils.incRateOfGrowth(blockMaps, x, y, 1);
    } else if (blockMaps.populationDensityMap.worldGet(x, y) &gt; 64) {
      // There is local demand for higher density housing
      placeResidential(map, x, y, 0, lpValue, zonePower);
      ZoneUtils.incRateOfGrowth(blockMaps, x, y, 8);
    }

    return;
  }

  if (population &lt; 40) {
    // Zone population not yet maxed out
    placeResidential(map, x, y, Math.floor(population / 8) - 1, lpValue, zonePower);
    ZoneUtils.incRateOfGrowth(blockMaps, x, y, 8);
  }
};


var freeZone = [0, 3, 6, 1, 4, 7, 2, 5, 8];

var degradeZone = function(map, x, y, blockMaps, population, lpValue, zonePower) {
  var xx, yy;
  if (population === 0)
    return;

  if (population &gt; 16) {
    // Degrade to a lower density block
    placeResidential(map, x, y, Math.floor((population - 24) / 8), lpValue, zonePower);
    ZoneUtils.incRateOfGrowth(blockMaps, x, y, -8);
    return;
  }

  if (population === 16) {
    // Already at lowest density: degrade to 8 individual houses
    map.setTile(x, y, TileValues.FREEZ, BLBNCNBIT | ZONEBIT);

    for (yy = y - 1; yy &lt;= y + 1; yy++) {
      for (xx = x - 1; xx &lt;= x + 1; xx++) {
        if (xx === x &amp;&amp; yy === y) continue;
        map.setTile(x, y, TileValues.LHTHR + lpValue + Random.getRandom(2), BLBNCNBIT);
      }
    }

    ZoneUtils.incRateOfGrowth(blockMaps, x, y, -8);
    return;
  }

  // Already down to individual houses. Remove one
  var i = 0;
  ZoneUtils.incRateOfGrowth(blockMaps, x, y, -1);

  for (xx = x - 1; xx &lt;= x + 1; xx++) {
    for (yy = y - 1; yy &lt;= y + 1; yy++, i++) {
      var currentValue = map.getTileValue(xx, yy);
      if (currentValue &gt;= TileValues.LHTHR &amp;&amp; currentValue &lt;= TileValues.HHTHR) {
        // We&#039;ve found a house. Replace it with the normal free zone tile
        map.setTile(xx, yy, freeZone[i] + TileValues.RESBASE, BLBNCNBIT);
        return;
      }
    }
  }
};


// Returns a score for the zone in the range -3000 - 3000
var evalResidential = function(blockMaps, x, y, traffic) {
  if (traffic === Traffic.NO_ROAD_FOUND)
    return -3000;

  var landValue = blockMaps.landValueMap.worldGet(x, y);
  landValue -= blockMaps.pollutionDensityMap.worldGet(x, y);

  if (landValue &lt; 0)
    landValue = 0;
  else
    landValue = Math.min(landValue * 32, 6000);

  return landValue - 3000;
};


var residentialFound = function(map, x, y, simData) {
  // If we choose to grow this zone, we will fill it with an index in the range 0-3 reflecting the land value and
  // pollution scores (higher is better). This is then used to select the variant to build
  var lpValue;

  // Notify the census
  simData.census.resZonePop += 1;

  // Also, notify the census of our population
  var tileValue = map.getTileValue(x, y);
  var population = getZonePopulation(map, x, y, tileValue);
  simData.census.resPop += population;

  var zonePower = map.getTile(x, y).isPowered();

  var trafficOK = Traffic.ROUTE_FOUND;

  // Occasionally check to see if the zone is connected to the road network. The chance of this happening increases
  // as the zone&#039;s population increases. Note: we will never execute this conditional if the zone is empty, as zero
  // will never be be bigger than any of the values Random will generate
  if (population &gt; Random.getRandom(35)) {
    // Is there a route from this zone to a commercial zone?
    trafficOK = simData.trafficManager.makeTraffic(x, y, simData.blockMaps, TileUtils.isCommercial);

    // If we&#039;re not connected to the road network, then going shopping will be a pain. Move out.
    if (trafficOK === Traffic.NO_ROAD_FOUND) {
      lpValue = ZoneUtils.getLandPollutionValue(simData.blockMaps, x, y);
      degradeZone(map, x, y, simData.blockMaps, population, lpValue, zonePower);
      return;
    }
  }

  // Sometimes we will randomly choose to assess this block. However, always assess it if it&#039;s empty or contains only
  // single houses.
  if (tileValue === TileValues.FREEZ || Random.getChance(7)) {
    // First, score the individual zone. This is a value in the range -3000 to 3000
    // Then take into account global demand for housing.
    var locationScore = evalResidential(simData.blockMaps, x, y, trafficOK);
    var zoneScore = simData.valves.resValve + locationScore;

    // Naturally unpowered zones should be penalized
    if (!zonePower)
      zoneScore = -500;

    // The residential demand valve has range -2000 to 2000, so taking into account the &quot;no traffic&quot; and
    // &quot;no power&quot; modifiers above, zoneScore must lie in the range -5500 - 5000.

    // Now, observe that if there are no roads we will never take this branch, as zoneScore will equal -3000.
    // Given the comment above about ranges for zoneScore, zoneScore - 26380, will be in the range -26729 to -20880.
    // getRandom16() has a range of 65536 possible numbers, in the range -32768 to 32767.
    // Of those, 9.2% will always be below zoneScore and hence will always take this branch and trigger zone growth.
    // 81.8% of them are above -20880, so nearly 82% of the time, we will never take this branch.
    // Thus, there&#039;s approximately a 9% chance that the value will be in the range, and we *might* grow.
    if (zoneScore &gt; -350 &amp;&amp; (zoneScore - 26380) &gt; Random.getRandom16Signed()) {
      // If this zone is empty, and residential demand is strong, we might make a hospital
      if (population === 0 &amp;&amp; Random.getChance(3)) {
        makeHospital(map, x, y, simData, zonePower);
        return;
      }

      // Get an index in the range 0-3 scoring the land desirability and pollution, and grow the zone to the next
      // population rank
      lpValue = ZoneUtils.getLandPollutionValue(simData.blockMaps, x, y);
      growZone(map, x, y, simData.blockMaps, population, lpValue, zonePower);
      return;
    }

    // Again, given the above, zoneScore + 26380 must lie in the range 20880 - 26030.
    // There is a 10.2% chance of getRandom16() always yielding a number &gt; 27994 which would take this branch.
    // There is a 89.7% chance of the number being below 20880 thus never triggering this branch, which leaves a
    // 0.1% chance of this branch being conditional on zoneScore.
    if (zoneScore &lt; 350 &amp;&amp; (zoneScore + 26380) &lt; Random.getRandom16Signed()) {
      // Get an index in the range 0-3 scoring the land desirability and pollution, and degrade to the next
      // lower ranked zone
      lpValue = ZoneUtils.getLandPollutionValue(simData.blockMaps, x, y);
      degradeZone(map, x, y, simData.blockMaps, population, lpValue, zonePower);
    }
  }
};


var makeHospital = function(map, x, y, simData, zonePower) {
  // We only build a hospital if the population requires it
  if (simData.census.needHospital &gt; 0) {
    ZoneUtils.putZone(map, x, y, TileValues.HOSPITAL, zonePower);
    simData.census.needHospital = 0;
    return;
  }
};


var hospitalFound = function(map, x, y, simData) {
  simData.census.hospitalPop += 1;

  // Degrade to an empty zone if a hospital is no longer sustainable
  if (simData.census.needHospital === -1) {
    if (Random.getRandom(20) === 0)
      ZoneUtils.putZone(map, x, y, TileValues.FREEZ, map.getTile(x, y).isPowered());
  }
};


var Residential = {
  registerHandlers: function(mapScanner, repairManager) {
    mapScanner.addAction(TileUtils.isResidentialZone, residentialFound);
    mapScanner.addAction(TileValues.HOSPITAL, hospitalFound);
    repairManager.addAction(TileValues.HOSPITAL, 15, 3);
  },
  getZonePopulation: getZonePopulation
};


export { Residential };</textarea
        >
      </div>
    </div>

    <footer class="footer">
      <div class="container">
        <p>.</p>
      </div>
    </footer>

    <script type="text/html" id="complexity-popover-template">
      <div class="complexity-notice">
        Complexity : {{ cyclomatic }} <br />
        Length : {{ halstead.length }} <br />
        Difficulty : {{ halstead.difficulty.toFixed(2) }} <br />
        Est # bugs : {{ halstead.bugs.toFixed(2) }}<br />
      </div>
    </script>

    <script
      type="text/javascript"
      src="../../assets/scripts/bundles/core-bundle.js"
    ></script>
    <script
      type="text/javascript"
      src="../../assets/scripts/bundles/codemirror.js"
    ></script>
    <script
      type="text/javascript"
      src="../../assets/scripts/codemirror.markpopovertext.js"
    ></script>
    <script type="text/javascript" src="report.js"></script>
    <script type="text/javascript" src="report.history.js"></script>
    <script
      type="text/javascript"
      src="../../assets/scripts/plato-file.js"
    ></script>
  </body>
</html>
