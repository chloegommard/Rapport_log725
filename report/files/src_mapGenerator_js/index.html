<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>Plato - src\mapGenerator.js</title>

    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="description" content="" />
    <meta name="author" content="" />

    <!--[if lt IE 9]>
      <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <link href="../../assets/css/vendor/morris.css" rel="stylesheet" />
    <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" />
    <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" />
    <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" />
    <link href="../../assets/css/plato.css" rel="stylesheet" />
    <link href="../../assets/css/plato-file.css" rel="stylesheet" />
  </head>

  <body>
    <div class="navbar navbar-fixed-top">
      <div class="container">
        <a class="navbar-brand" href="http://github.com/es-analysis/plato"
          >Plato on Github</a
        >
        <ul class="nav navbar-nav">
          <li>
            <a href="../../index.html">Report Home</a>
          </li>
        </ul>
      </div>
    </div>

    <div class="jumbotron">
      <div class="container">
        <h1>src\mapGenerator.js</h1>
      </div>
    </div>

    <div class="container aggregate-stats">
      <div class="row">
        <div class="col-md-6">
          <h2 class="header">
            Maintainability
            <a
              href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"
              ><i
                class="icon icon-info-sign"
                rel="popover"
                data-placement="top"
                data-trigger="hover"
                data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability."
                data-original-title="Maintainability Index"
                data-container="body"
              ></i
            ></a>
          </h2>
          <p class="stat">58.49</p>
        </div>
        <div class="col-md-6">
          <h2 class="header">
            Lines of code
            <i
              class="icon icon-info-sign"
              rel="popover"
              data-placement="top"
              data-trigger="hover"
              data-content="Source Lines of Code / Logical Lines of Code"
              data-original-title="SLOC/LSLOC"
              data-container="body"
            ></i>
          </h2>
          <p class="stat">507</p>
        </div>
      </div>
      <div class="row historical">
        <div class="col-md-6">
          <p id="chart_historical_maint" class="chart"></p>
        </div>
        <div class="col-md-6">
          <p id="chart_historical_sloc" class="chart"></p>
        </div>
      </div>
      <div class="row">
        <div class="col-md-6">
          <h2 class="header">
            Difficulty
            <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"
              ><i
                class="icon icon-info-sign"
                rel="popover"
                data-placement="top"
                data-trigger="hover"
                data-content="The difficulty measure is related to the difficulty of the program to write or understand."
                data-original-title="Difficulty"
                data-container="body"
              ></i
            ></a>
          </h2>
          <p class="stat">152.51</p>
        </div>
        <div class="col-md-6">
          <h2 class="header">
            Estimated Errors
            <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"
              ><i
                class="icon icon-info-sign"
                rel="popover"
                data-placement="top"
                data-trigger="hover"
                data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation."
                data-original-title="Delivered Bugs"
                data-container="body"
              ></i
            ></a>
          </h2>
          <p class="stat">5.11</p>
        </div>
      </div>
    </div>

    <div class="container charts">
      <div class="row">
        <h2 class="header">Function weight</h2>
      </div>
      <div class="row">
        <div class="col-md-6">
          <h3 class="chart-header">
            By Complexity
            <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"
              ><i
                class="icon icon-info-sign"
                rel="popover"
                data-placement="top"
                data-trigger="hover"
                data-content="This metric counts the number of distinct paths through a block of code. Lower values are better."
                data-original-title="Cyclomatic Complexity"
                data-container="body"
              ></i
            ></a>
          </h3>
          <div id="fn-by-complexity" class="stat"></div>
        </div>
        <div class="col-md-6">
          <h3 class="chart-header">
            By SLOC
            <i
              class="icon icon-info-sign"
              rel="popover"
              data-placement="top"
              data-trigger="hover"
              data-content="Source Lines of Code / Logical Lines of Code"
              data-original-title="SLOC/LSLOC"
              data-container="body"
            ></i>
          </h3>
          <div id="fn-by-sloc" class="stat"></div>
        </div>
      </div>
    </div>

    <div class="container">
      <div class="row">
        <textarea id="file-source" class="col-md-12">
/* micropolisJS. Adapted by Graeme McCutcheon from Micropolis.
 *
 * This code is released under the GNU GPL v3, with some additional terms.
 * Please see the files LICENSE and COPYING for details. Alternatively,
 * consult http://micropolisjs.graememcc.co.uk/LICENSE and
 * http://micropolisjs.graememcc.co.uk/COPYING
 *
 */

import { forEachCardinalDirection, getRandomCardinalDirection, getRandomDirection } from &#039;./direction&#039;;
import { GameMap } from &#039;./gameMap&#039;;
import { Position } from &#039;./position&#039;;
import { Random } from &#039;./random&#039;;
import { BLBNBIT, BULLBIT } from &quot;./tileFlags&quot;;
import { CHANNEL, DIRT, REDGE, RIVER, WATER_LOW, WATER_HIGH, WOODS, WOODS_LOW, WOODS_HIGH } from &quot;./tileValues&quot;;

var TERRAIN_CREATE_ISLAND;
var TERRAIN_TREE_LEVEL = -1;
var TERRAIN_LAKE_LEVEL = -1;
var TERRAIN_CURVE_LEVEL = -1;
var ISLAND_RADIUS = 18;

var MapGenerator = function(w, h) {
  w = w || 120;
  h = h || 100;

  TERRAIN_CREATE_ISLAND = Random.getRandom(2) - 1;

  var map = new GameMap(w, h);
  // Construct land.
  if (TERRAIN_CREATE_ISLAND &lt; 0) {
    if (Random.getRandom(100) &lt; 10) {
      makeIsland(map);
      return map;
    }
  }

  if (TERRAIN_CREATE_ISLAND === 1)
    makeNakedIsland(map);
  else
    clearMap(map);

  // Lay a river.
  if (TERRAIN_CURVE_LEVEL !== 0) {
    var terrainXStart = 40 + Random.getRandom(map.width - 80);
    var terrainYStart = 33 + Random.getRandom(map.height - 67);

    var terrainPos = new Position(terrainXStart, terrainYStart);
    doRivers(map, terrainPos);
  }

  // Lay a few lakes.
  if (TERRAIN_LAKE_LEVEL !== 0)
      makeLakes(map);

  smoothRiver(map);

  // And add trees.
  if (TERRAIN_TREE_LEVEL !== 0)
      doTrees(map);

  return map;
};


var clearMap = function(map) {
  for (var x = 0; x &lt; map.width; x++) {
    for (var y = 0; y &lt; map.height; y++) {
      map.setTile(x, y, DIRT, 0);
    }
  }
};


var clearUnnatural = function(map) {
  for (var x = 0; x &lt; map.width; x++) {
    for (var y = 0; y &lt; map.height; y++) {
      var tileValue = map.getTileValue(x, y);
      if (tileValue &gt; WOODS)
        map.setTile(x, y, DIRT, 0);
    }
  }
};


var makeNakedIsland = function(map) {
  var terrainIslandRadius = ISLAND_RADIUS;
  var x, y;

  for (x = 0; x &lt; map.width; x++) {
    for (y = 0; y &lt; map.height; y++) {
      if ((x &lt; 5) || (x &gt;= map.width - 5) ||
          (y &lt; 5) || (y &gt;= map.height - 5)) {
        map.setTile(x, y, RIVER, 0);
      } else {
        map.setTile(x, y, DIRT, 0);
      }
    }
  }

  for (x = 0; x &lt; map.width - 5; x += 2) {
    var mapY = Random.getERandom(terrainIslandRadius);
    plopBRiver(map, new Position(x, mapY));

    mapY = (map.height - 10) - Random.getERandom(terrainIslandRadius);
    plopBRiver(map, new Position(x, mapY));

    plopSRiver(map, new Position(x, 0));
    plopSRiver(map, new Position(x, map.height - 6));
  }

  for (y = 0; y &lt; map.height - 5; y += 2) {
    var mapX = Random.getERandom(terrainIslandRadius);
    plopBRiver(map, new Position(mapX, y));

    mapX = map.width - 10 - Random.getERandom(terrainIslandRadius);
    plopBRiver(map, new Position(mapX, y));

    plopSRiver(map, new Position(0, y));
    plopSRiver(map, new Position(map.width - 6, y));
  }
};


var makeIsland = function(map) {
  makeNakedIsland(map);
  smoothRiver(map);
  doTrees(map);
};


var makeLakes = function(map) {
  var numLakes;
  if (TERRAIN_LAKE_LEVEL &lt; 0)
      numLakes = Random.getRandom(10);
  else
      numLakes = TERRAIN_LAKE_LEVEL / 2;

  while (numLakes &gt; 0) {
    var x = Random.getRandom(map.width - 21) + 10;
    var y = Random.getRandom(map.height - 20) + 10;

    makeSingleLake(map, new Position(x, y));
    numLakes--;
  }
};


var makeSingleLake = function(map, pos) {
  var numPlops = Random.getRandom(12) + 2;

  while (numPlops &gt; 0) {
    var plopPos = new Position(pos, Random.getRandom(12) - 6, Random.getRandom(12) - 6);

    if (Random.getRandom(4))
        plopSRiver(map, plopPos);
    else
        plopBRiver(map, plopPos);

    numPlops--;
  }
};


var treeSplash = function(map, x, y) {
  var numTrees;

  if (TERRAIN_TREE_LEVEL &lt; 0)
    numTrees = Random.getRandom(150) + 50;
  else
    numTrees = Random.getRandom(100 + (TERRAIN_TREE_LEVEL * 2)) + 50;

  var treePos = new Position(x, y);

  while (numTrees &gt; 0) {
    var dir = getRandomDirection();
    treePos = Position.move(treePos, dir);

    if (!map.isPositionInBounds(treePos))
      return;

    if (map.getTileValue(treePos) === DIRT)
      map.setTile(treePos, WOODS, BLBNBIT);

    numTrees--;
  }
};


var doTrees = function(map) {
  var amount;

  if (TERRAIN_TREE_LEVEL &lt; 0)
    amount = Random.getRandom(100) + 50;
  else
    amount = TERRAIN_TREE_LEVEL + 3;

  for (var x = 0; x &lt; amount; x++) {
      var xloc = Random.getRandom(map.width - 1);
      var yloc = Random.getRandom(map.height - 1);
      treeSplash(map, xloc, yloc);
  }

  smoothTrees(map);
  smoothTrees(map);
};


var riverEdges = [
  13 | BULLBIT, 13 | BULLBIT, 17 | BULLBIT, 15 | BULLBIT,
   5 | BULLBIT,        RIVER, 19 | BULLBIT, 17 | BULLBIT,
   9 | BULLBIT, 11 | BULLBIT,        RIVER, 13 | BULLBIT,
   7 | BULLBIT,  9 | BULLBIT,  5 | BULLBIT,        RIVER];

var smoothRiver = function(map) {
  var dx = [-1,  0,  1,  0];
  var dy = [0,  1,  0, -1];

  for (var x = 0; x &lt; map.width; x++) {
    for (var y = 0; y &lt; map.height; y++) {
      if (map.getTileValue(x, y) === REDGE) {
        var bitIndex = 0;

        for (var z = 0; z &lt; 4; z++) {
          bitIndex = bitIndex &lt;&lt; 1;
          var xTemp = x + dx[z];
          var yTemp = y + dy[z];
          if (map.testBounds(xTemp, yTemp) &amp;&amp;
              map.getTileValue(xTemp, yTemp) !== DIRT &amp;&amp;
              (map.getTileValue(xTemp, yTemp) &lt; WOODS_LOW ||
               map.getTileValue(xTemp, yTemp) &gt; WOODS_HIGH)) {
            bitIndex++;
          }
        }

        var temp = riverEdges[bitIndex &amp; 15];
        if (temp !== RIVER &amp;&amp; Random.getRandom(1))
          temp++;

        map.setTileValue(x, y, temp, 0);
      }
    }
  }
};


var isTree = function(tileValue) {
  return tileValue &gt;= WOODS_LOW &amp;&amp; tileValue &lt;= WOODS_HIGH;
};


var smoothTrees = function(map) {
  for (var x = 0; x &lt; map.width; x++) {
    for (var y = 0; y &lt; map.height; y++) {
      if (isTree(map.getTileValue(x, y)))
        smoothTreesAt(map, x, y, false);
    }
  }
};


var treeTable = [
   0,   0,  0, 34,
   0,   0, 36, 35,
   0,  32,  0, 33,
  30,  31, 29, 37];

var smoothTreesAt = function(map, x, y, preserve) {
  var dx = [-1,  0,  1,  0 ];
  var dy = [ 0,  1,  0, -1 ];
  if (!isTree(map.getTileValue(x, y)))
      return;

  var bitIndex = 0;
  for (var i = 0; i &lt; 4; i++) {
    bitIndex = bitIndex &lt;&lt; 1;
    var xTemp = x + dx[i];
    var yTemp = y + dy[i];
    if (map.testBounds(xTemp, yTemp) &amp;&amp;
        isTree(map.getTileValue(xTemp, yTemp)))
      bitIndex++;
  }

  var temp = treeTable[bitIndex &amp; 15];
  if (temp) {
    if (temp !== WOODS) {
      if ((x + y) &amp; 1)
          temp = temp - 8;
    }
    map.setTile(x, y, temp, BLBNBIT);
  } else {
    if (!preserve)
      map.setTileValue(x, y, temp, 0);
  }
};



var doRivers = function(map, terrainPos) {
  var riverDir = getRandomCardinalDirection();
  doBRiver(map, terrainPos, riverDir, riverDir);

  riverDir = riverDir.oppositeDirection();
  var terrainDir = doBRiver(map, terrainPos, riverDir, riverDir);

  riverDir = getRandomCardinalDirection();
  doSRiver(map, terrainPos, riverDir, terrainDir);
};


var doBRiver = function(map, pos, riverDir, terrainDir) {
  var rate1, rate2;

  if (TERRAIN_CURVE_LEVEL &lt; 0) {
    rate1 = 100;
    rate2 = 200;
  } else {
    rate1 = TERRAIN_CURVE_LEVEL + 10;
    rate2 = TERRAIN_CURVE_LEVEL + 100;
  }

  while (map.testBounds(pos.x + 4, pos.y + 4)) {
    plopBRiver(map, pos);
    if (Random.getRandom(rate1) &lt; 10) {
      terrainDir = riverDir;
    } else {
      if (Random.getRandom(rate2) &gt; 90)
        terrainDir = terrainDir.rotateClockwise();
      if (Random.getRandom(rate2) &gt; 90)
        terrainDir = terrainDir.rotateCounterClockwise();
    }
    pos = Position.move(pos, terrainDir);
  }

  return terrainDir;
};


var doSRiver = function(map, pos, riverDir, terrainDir) {
  var rate1, rate2;

  if (TERRAIN_CURVE_LEVEL &lt; 0) {
    rate1 = 100;
    rate2 = 200;
  } else {
    rate1 = TERRAIN_CURVE_LEVEL + 10;
    rate2 = TERRAIN_CURVE_LEVEL + 100;
  }

  while (map.testBounds(pos.x + 3, pos.y + 3)) {
    plopSRiver(map, pos);
    if (Random.getRandom(rate1) &lt; 10) {
      terrainDir = riverDir;
    } else {
      if (Random.getRandom(rate2) &gt; 90)
        terrainDir = terrainDir.rotateClockwise();
      if (Random.getRandom(rate2) &gt; 90)
        terrainDir = terrainDir.rotateCounterClockwise();
    }
    pos = Position.move(pos, terrainDir);
  }

  return terrainDir;
};


var putOnMap = function(map, newVal, x, y) {
  if (newVal === 0)
    return;

  if (!map.testBounds(x, y))
    return;

  var tileValue = map.getTileValue(x, y);

  if (tileValue !== DIRT) {
    if (tileValue === RIVER) {
      if (newVal !== CHANNEL)
          return;
    }
    if (tileValue === CHANNEL)
      return;
  }
  map.setTile(x, y, newVal, 0);
};


var plopBRiver = function(map, pos) {
  var BRMatrix = [
   [    0,     0,     0, REDGE,  REDGE,  REDGE,     0,     0,     0],
   [    0,     0, REDGE, RIVER,  RIVER,  RIVER, REDGE,     0,     0],
   [    0, REDGE, RIVER, RIVER,  RIVER,  RIVER, RIVER, REDGE,     0],
   [REDGE, RIVER, RIVER, RIVER,  RIVER,  RIVER, RIVER, RIVER, REDGE],
   [REDGE, RIVER, RIVER, RIVER, CHANNEL, RIVER, RIVER, RIVER, REDGE],
   [REDGE, RIVER, RIVER, RIVER,  RIVER,  RIVER, RIVER, RIVER, REDGE],
   [    0, REDGE, RIVER, RIVER,  RIVER,  RIVER, RIVER, REDGE,     0],
   [    0,     0, REDGE, RIVER,  RIVER,  RIVER, REDGE,     0,     0],
   [    0,     0,     0, REDGE,  REDGE,  REDGE,     0,     0,     0]];

  for (var x = 0; x &lt; 9; x++) {
    for (var y = 0; y &lt; 9; y++) {
      putOnMap(map, BRMatrix[y][x], pos.x + x, pos.y + y);
    }
  }
};


var plopSRiver = function(map, pos) {
  var SRMatrix = [
    [    0,     0, REDGE, REDGE,     0,     0],
    [    0, REDGE, RIVER, RIVER, REDGE,     0],
    [REDGE, RIVER, RIVER, RIVER, RIVER, REDGE],
    [REDGE, RIVER, RIVER, RIVER, RIVER, REDGE],
    [    0, REDGE, RIVER, RIVER, REDGE,     0],
    [    0,     0, REDGE, REDGE,     0,     0]];


  for (var x = 0; x &lt; 6; x++) {
    for (var y = 0; y &lt; 6; y++) {
      putOnMap(map, SRMatrix[y][x], pos.x + x, pos.y + y);
    }
  }
};


var smoothWater = function(map) {
  var x, y, tile, pos, dir;

  for (x = 0; x &lt; map.width; x++) {
    for (y = 0; y &lt; map.height; y++) {
      tile = map.getTileValue(x, y);

      if (tile &gt;= WATER_LOW &amp;&amp; tile &lt;= WATER_HIGH) {
        pos = new Position(x, y);
        let stop = false;

        forEachCardinalDirection(dir =&gt; {
          if (stop) {
            return;
          }

          tile = map.getTileFromMap(pos, dir, WATER_LOW);

          /* If nearest object is not water: */
          if (tile &lt; WATER_LOW || tile &gt; WATER_HIGH) {
            map.setTileValue(x, y, REDGE, 0); /* set river edge */
            stop = true; // Continue with next tile
          }
        });
      }
    }
  }

  for (x = 0; x &lt; map.width; x++) {
    for (y = 0; y &lt; map.height; y++) {
      tile = map.getTileValue(x, y);

      if (tile !== CHANNEL &amp;&amp; tile &gt;= WATER_LOW &amp;&amp; tile &lt;= WATER_HIGH) {
        var makeRiver = true;

        pos = new Position(x, y);

        forEachCardinalDirection(dir =&gt; {
          if (!makeRiver) {
            return;
          }

          tile = map.getTileFromMapOrDefault(pos, dir, WATER_LOW);

          if (tile &lt; WATER_LOW || tile &gt; WATER_HIGH) {
            makeRiver = false;
          }
        });

        if (makeRiver)
          map.setTileValue(x, y, RIVER, 0);
      }
    }
  }

  for (x = 0; x &lt; map.width; x++) {
    for (y = 0; y &lt; map.height; y++) {
      tile = map.getTileValue(x, y);

      if (tile &gt;= WOODS_LOW &amp;&amp; tile &lt;= WOODS_HIGH) {
        pos = new Position(x, y);
        let stop = false;

        forEachCardinalDirection(dir =&gt; {
          if (stop) {
            return;
          }

          tile = map.getTileFromMapOrDefault(pos, dir, TILE_INVALID);

          if (tile === RIVER || tile === CHANNEL) {
            map.setTileValue(x, y, REDGE, 0); /* make it water&#039;s edge */
            stop = true;
          }
        });
      }
    }
  }
};


export { MapGenerator };</textarea
        >
      </div>
    </div>

    <footer class="footer">
      <div class="container">
        <p>.</p>
      </div>
    </footer>

    <script type="text/html" id="complexity-popover-template">
      <div class="complexity-notice">
        Complexity : {{ cyclomatic }} <br />
        Length : {{ halstead.length }} <br />
        Difficulty : {{ halstead.difficulty.toFixed(2) }} <br />
        Est # bugs : {{ halstead.bugs.toFixed(2) }}<br />
      </div>
    </script>

    <script
      type="text/javascript"
      src="../../assets/scripts/bundles/core-bundle.js"
    ></script>
    <script
      type="text/javascript"
      src="../../assets/scripts/bundles/codemirror.js"
    ></script>
    <script
      type="text/javascript"
      src="../../assets/scripts/codemirror.markpopovertext.js"
    ></script>
    <script type="text/javascript" src="report.js"></script>
    <script type="text/javascript" src="report.history.js"></script>
    <script
      type="text/javascript"
      src="../../assets/scripts/plato-file.js"
    ></script>
  </body>
</html>
